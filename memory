0x00_0000 - 0x00_0fff :   4 KB : IDT
0x00_1000 - 0x00_1fff :   4 KB : page table 4
0x00_2000 - 0x00_2fff :   4 KB : page table 3
0x00_3000 - 0x00_3fff :   4 KB : page table 2
0x00_4000 - 0x00_4fff :   4 KB : int 0x15, eax = 0xe820 memory table
0x00_5000 - 0x00_7bff :  11 KB : bootloader stack
0x00_7c00 - 0x07_ffff : 481 KB : kernel
0x08_0000 - 0x09_ffff : 128 KB : EBDA (So available once in long mode)
0x0a_0000 - 0x0c_ffff : 160 KB : Video
0x0c_8000 - 0x0e_ffff : 160 KB : BIOS Expansions
0x0f_0000 - 0x0f_ffff :  64 KB : Motherboard BIOS until long mode, then kernel stack (maybe not okay; depends on int 15 info)
//0x10_0000 - 0x2f_ffff :   2 MB : l2 tables for first 512 GB of address space
0x10_0000 - 0x1f_ffff :   1 MB : l2 tables for first 256 GB of address space
0x20_0000 - 0x2f_ffff :   1 MB : l2 tables for misc use
0x30_0000 - 0x30_fff0 :  64 KB : Kernel stack in long mode (16 bytes less than 64 KB)
0x31_0000 - ????????? : ??? ?? : Heap





0x0000_0000 - 0x000a_0000 available in long mode

Page tables have to be set up below 1 MB and not in any BIOS area before switching to long mode.
(Can be basic ones that are changed later...)

But IDT can be set up after long mode.



        page_table_l4 equ 0x1000
        page_table_l3 equ 0x2000
        page_table_l2 equ 0x3000
        stack_bottom equ 0x4000
        stack_top equ 0x7bff
        idt equ 0               ; 0-0x1000 available in long mode



0x0_0000 - 0x0_0fff :   4 KB : IDT
0x0_1000 - 0x0_1fff :   4 KB : page table 4
0x0_2000 - 0x0_2fff :   4 KB : page table 3
0x0_3000 - 0x0_3fff :   4 KB : page table 2
0x0_4000 - 0x0_7bff :  15 KB : stack (Space for 1920 quad words)
0x0_7c00 - 0x7_ffff : 481 KB : kernel
0x8_0000 - 0x9_ffff : 128 KB : EBDA (So available once in long mode)
0xa_0000 - 0xc_ffff : 160 KB : Video
0xc_8000 - 0xe_ffff : 160 KB : BIOS Expansions
0xf_0000 - 0xf_ffff :  64 KB : Motherboard BIOS

I'm not 100% sure it's safe to overwrite BIOS itself (not just data area), but it seem like it should be?
So once I'm in long mode, I can move the stack to that last 224 KB?  (wait_loop can set stack to 0xfffff?)

Well, tried that, and I guess not...  Reboots when I press a key.
But that's not quite the misbehavior I expected if it's not safe.
Although, if the system is still using that area, I guess it could make sense.

Okay, but 0xeffff does work, so we're still making our stack 10 times bigger with that memory area we weren't
otherwise using.

If kernel is ever larger than 481 KB adn less than 609 KB, we can have the kernel load more of itself into that
  EBDA area.

Can I give the kernel stack its own segment?  So CPU can call an interrupt (trying to access memory outside of
  segment) when trying to push something on a full stack?  (Rather than just silently doing bad things...)




Ahh, I think canonical address means first bits are same as whatever the most significant bit is!
So when they say "Bits 63:48 are a sign extension of bit 47 as required for canonical address forms,"
  "sign extension," I guess they're saying that address 0x800000000000 and up, in canonical form, must
  be stored as 0xffff800000000000?  That first word has to be either 0x0000 (for address 0x7fffffffffff
  and below), or 0xffff (for address 0x800000000000 and above).  So 0x800000000000 isn't a valid address.
  (Well, it's not in canonical form...)

Oh, but it's not just a funny way of writing 0x800000000000!  0x800000000000 *doesn't exist*!  So it's not so
bad.  It's fine, actually.  I thought you had to take a real address, and then flip a bunch of bits if it was
above a certain amount.  It's just that the address space is only 48-bit (currently, with I think 57-bit
possible and coming soon-ish?), and rathe than have that address space just be the lowest 2**48 addresses,
it's actually the lowset 2**24 and the highest 2**24.