0x0000_0000 - 0x000a_0000 available in long mode

Page tables have to be set up below 1 MB and not in any BIOS area before switching to long mode.
(Can be basic ones that are changed later...)

But IDT can be set up after long mode.



        page_table_l4 equ 0x1000
        page_table_l3 equ 0x2000
        page_table_l2 equ 0x3000
        stack_bottom equ 0x4000
        stack_top equ 0x7bff
        idt equ 0               ; 0-0x1000 available in long mode



0x0_0000 - 0x0_0fff :   4 KB : IDT
0x0_1000 - 0x0_1fff :   4 KB : page table 4
0x0_2000 - 0x0_2fff :   4 KB : page table 3
0x0_3000 - 0x0_3fff :   4 KB : page table 2
0x0_4000 - 0x0_7bff :  15 KB : stack (Space for 1920 quad words)
0x0_7c00 - 0x7_ffff : 481 KB : kernel
0x8_0000 - 0x9_ffff : 128 KB : EBDA (So available once in long mode)
0xa_0000 - 0xc_ffff : 160 KB : Video
0xc_8000 - 0xe_ffff : 160 KB : BIOS Expansions
0xf_0000 - 0xf_ffff :  64 KB : Motherboard BIOS

I'm not 100% sure it's safe to overwrite BIOS itself (not just data area), but it seem like it should be?
So once I'm in long mode, I can move the stack to that last 224 KB?  (wait_loop can set stack to 0xfffff?)

Well, tried that, and I guess not...  Reboots when I press a key.
But that's not quite the misbehavior I expected if it's not safe.
Although, if the system is still using that area, I guess it could make sense.

Okay, but 0xeffff does work, so we're still making our stack 10 times bigger with that memory area we weren't
otherwise using.

If kernel is ever larger than 481 KB adn less than 609 KB, we can have the kernel load more of itself into that
  EBDA area.

Can I give the kernel stack its own segment?  So CPU can call an interrupt (trying to access memory outside of
  segment) when trying to push something on a full stack?  (Rather than just silently doing bad things...)